// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_
#define FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_

#include "flatbuffers/flatbuffers.h"

namespace Editor {

struct EditorRoot;
struct EditorRootT;

struct NodeTree;
struct NodeTreeT;

struct Sprite;
struct SpriteT;

struct Label;
struct LabelT;

struct Button;
struct ButtonT;

struct Body;
struct BodyT;

struct Fixture;
struct FixtureT;

struct Joint;
struct JointT;

struct Vec4b;

struct Vec4f;

struct Vec2f;

struct Sizef;

enum NodeType {
  NodeType_BUTTON = 0,
  NodeType_SPRITE = 1,
  NodeType_LAYOUT = 2,
  NodeType_LABEL = 3,
  NodeType_UI_SCROLL_VIEW = 4,
  NodeType_UI_LIST_VIEW = 5,
  NodeType_MIN = NodeType_BUTTON,
  NodeType_MAX = NodeType_UI_LIST_VIEW
};

inline NodeType (&EnumValuesNodeType())[6] {
  static NodeType values[] = {
    NodeType_BUTTON,
    NodeType_SPRITE,
    NodeType_LAYOUT,
    NodeType_LABEL,
    NodeType_UI_SCROLL_VIEW,
    NodeType_UI_LIST_VIEW
  };
  return values;
}

inline const char **EnumNamesNodeType() {
  static const char *names[] = {
    "BUTTON",
    "SPRITE",
    "LAYOUT",
    "LABEL",
    "UI_SCROLL_VIEW",
    "UI_LIST_VIEW",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesNodeType()[index];
}

enum Component {
  Component_NONE = 0,
  Component_Sprite = 1,
  Component_Label = 2,
  Component_Button = 3,
  Component_MIN = Component_NONE,
  Component_MAX = Component_Button
};

inline Component (&EnumValuesComponent())[4] {
  static Component values[] = {
    Component_NONE,
    Component_Sprite,
    Component_Label,
    Component_Button
  };
  return values;
}

inline const char **EnumNamesComponent() {
  static const char *names[] = {
    "NONE",
    "Sprite",
    "Label",
    "Button",
    nullptr
  };
  return names;
}

inline const char *EnumNameComponent(Component e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesComponent()[index];
}

template<typename T> struct ComponentTraits {
  static const Component enum_value = Component_NONE;
};

template<> struct ComponentTraits<Sprite> {
  static const Component enum_value = Component_Sprite;
};

template<> struct ComponentTraits<Label> {
  static const Component enum_value = Component_Label;
};

template<> struct ComponentTraits<Button> {
  static const Component enum_value = Component_Button;
};

struct ComponentUnion {
  Component type;
  void *value;

  ComponentUnion() : type(Component_NONE), value(nullptr) {}
  ComponentUnion(ComponentUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Component_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ComponentUnion(const ComponentUnion &) FLATBUFFERS_NOEXCEPT;
  ComponentUnion &operator=(const ComponentUnion &u) FLATBUFFERS_NOEXCEPT
    { ComponentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ComponentUnion &operator=(ComponentUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ComponentUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ComponentTraits<typename T::TableType>::enum_value;
    if (type != Component_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Component type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  SpriteT *AsSprite() {
    return type == Component_Sprite ?
      reinterpret_cast<SpriteT *>(value) : nullptr;
  }
  const SpriteT *AsSprite() const {
    return type == Component_Sprite ?
      reinterpret_cast<const SpriteT *>(value) : nullptr;
  }
  LabelT *AsLabel() {
    return type == Component_Label ?
      reinterpret_cast<LabelT *>(value) : nullptr;
  }
  const LabelT *AsLabel() const {
    return type == Component_Label ?
      reinterpret_cast<const LabelT *>(value) : nullptr;
  }
  ButtonT *AsButton() {
    return type == Component_Button ?
      reinterpret_cast<ButtonT *>(value) : nullptr;
  }
  const ButtonT *AsButton() const {
    return type == Component_Button ?
      reinterpret_cast<const ButtonT *>(value) : nullptr;
  }
};

bool VerifyComponent(flatbuffers::Verifier &verifier, const void *obj, Component type);
bool VerifyComponentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BodyType {
  BodyType_STATIC = 0,
  BodyType_DYNAMIC = 1,
  BodyType_KINEMATIC = 2,
  BodyType_MIN = BodyType_STATIC,
  BodyType_MAX = BodyType_KINEMATIC
};

inline BodyType (&EnumValuesBodyType())[3] {
  static BodyType values[] = {
    BodyType_STATIC,
    BodyType_DYNAMIC,
    BodyType_KINEMATIC
  };
  return values;
}

inline const char **EnumNamesBodyType() {
  static const char *names[] = {
    "STATIC",
    "DYNAMIC",
    "KINEMATIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameBodyType(BodyType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesBodyType()[index];
}

enum FixtureType {
  FixtureType_POLYGON = 0,
  FixtureType_CIRCLE = 1,
  FixtureType_LINE = 2,
  FixtureType_MIN = FixtureType_POLYGON,
  FixtureType_MAX = FixtureType_LINE
};

inline FixtureType (&EnumValuesFixtureType())[3] {
  static FixtureType values[] = {
    FixtureType_POLYGON,
    FixtureType_CIRCLE,
    FixtureType_LINE
  };
  return values;
}

inline const char **EnumNamesFixtureType() {
  static const char *names[] = {
    "POLYGON",
    "CIRCLE",
    "LINE",
    nullptr
  };
  return names;
}

inline const char *EnumNameFixtureType(FixtureType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFixtureType()[index];
}

enum JointType {
  JointType_REVOLUTE = 0,
  JointType_PRISMATIC = 1,
  JointType_MIN = JointType_REVOLUTE,
  JointType_MAX = JointType_PRISMATIC
};

inline JointType (&EnumValuesJointType())[2] {
  static JointType values[] = {
    JointType_REVOLUTE,
    JointType_PRISMATIC
  };
  return values;
}

inline const char **EnumNamesJointType() {
  static const char *names[] = {
    "REVOLUTE",
    "PRISMATIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameJointType(JointType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesJointType()[index];
}

MANUALLY_ALIGNED_STRUCT(1) Vec4b FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t a_;
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  Vec4b() {
    memset(this, 0, sizeof(Vec4b));
  }
  Vec4b(uint8_t _a, uint8_t _r, uint8_t _g, uint8_t _b)
      : a_(flatbuffers::EndianScalar(_a)),
        r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  uint8_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
STRUCT_END(Vec4b, 4);

MANUALLY_ALIGNED_STRUCT(4) Vec4f FLATBUFFERS_FINAL_CLASS {
 private:
  float a_;
  float r_;
  float g_;
  float b_;

 public:
  Vec4f() {
    memset(this, 0, sizeof(Vec4f));
  }
  Vec4f(float _a, float _r, float _g, float _b)
      : a_(flatbuffers::EndianScalar(_a)),
        r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
  float r() const {
    return flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
STRUCT_END(Vec4f, 16);

MANUALLY_ALIGNED_STRUCT(4) Vec2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2f() {
    memset(this, 0, sizeof(Vec2f));
  }
  Vec2f(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(Vec2f, 8);

MANUALLY_ALIGNED_STRUCT(4) Sizef FLATBUFFERS_FINAL_CLASS {
 private:
  float width_;
  float height_;

 public:
  Sizef() {
    memset(this, 0, sizeof(Sizef));
  }
  Sizef(float _width, float _height)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)) {
  }
  float width() const {
    return flatbuffers::EndianScalar(width_);
  }
  float height() const {
    return flatbuffers::EndianScalar(height_);
  }
};
STRUCT_END(Sizef, 8);

struct EditorRootT : public flatbuffers::NativeTable {
  typedef EditorRoot TableType;
  std::vector<std::string> textures;
  std::vector<std::unique_ptr<NodeTreeT>> nodes;
  EditorRootT() {
  }
};

struct EditorRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EditorRootT NativeTableType;
  enum {
    VT_TEXTURES = 4,
    VT_NODES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.Verify(textures()) &&
           verifier.VerifyVectorOfStrings(textures()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
  EditorRootT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EditorRootT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EditorRoot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EditorRootT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EditorRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> textures) {
    fbb_.AddOffset(EditorRoot::VT_TEXTURES, textures);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> nodes) {
    fbb_.AddOffset(EditorRoot::VT_NODES, nodes);
  }
  explicit EditorRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EditorRootBuilder &operator=(const EditorRootBuilder &);
  flatbuffers::Offset<EditorRoot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EditorRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<EditorRoot> CreateEditorRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> nodes = 0) {
  EditorRootBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_textures(textures);
  return builder_.Finish();
}

inline flatbuffers::Offset<EditorRoot> CreateEditorRootDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *textures = nullptr,
    const std::vector<flatbuffers::Offset<NodeTree>> *nodes = nullptr) {
  return Editor::CreateEditorRoot(
      _fbb,
      textures ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*textures) : 0,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*nodes) : 0);
}

flatbuffers::Offset<EditorRoot> CreateEditorRoot(flatbuffers::FlatBufferBuilder &_fbb, const EditorRootT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NodeTreeT : public flatbuffers::NativeTable {
  typedef NodeTree TableType;
  std::string name;
  std::unique_ptr<Vec2f> position;
  std::unique_ptr<Vec2f> scale;
  std::unique_ptr<Sizef> size;
  int32_t rotation;
  std::unique_ptr<Vec2f> anchor;
  int32_t zOrder;
  uint8_t opacity;
  std::unique_ptr<Vec4f> color;
  std::vector<std::unique_ptr<NodeTreeT>> children;
  NodeType type;
  ComponentUnion component;
  bool enablePhysics;
  std::unique_ptr<BodyT> physics;
  NodeTreeT()
      : rotation(0),
        zOrder(0),
        opacity(0),
        type(NodeType_BUTTON),
        enablePhysics(false) {
  }
};

struct NodeTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeTreeT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_POSITION = 6,
    VT_SCALE = 8,
    VT_SIZE = 10,
    VT_ROTATION = 12,
    VT_ANCHOR = 14,
    VT_ZORDER = 16,
    VT_OPACITY = 18,
    VT_COLOR = 20,
    VT_CHILDREN = 22,
    VT_TYPE = 24,
    VT_COMPONENT_TYPE = 26,
    VT_COMPONENT = 28,
    VT_ENABLEPHYSICS = 30,
    VT_PHYSICS = 32
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Vec2f *position() const {
    return GetStruct<const Vec2f *>(VT_POSITION);
  }
  const Vec2f *scale() const {
    return GetStruct<const Vec2f *>(VT_SCALE);
  }
  const Sizef *size() const {
    return GetStruct<const Sizef *>(VT_SIZE);
  }
  int32_t rotation() const {
    return GetField<int32_t>(VT_ROTATION, 0);
  }
  const Vec2f *anchor() const {
    return GetStruct<const Vec2f *>(VT_ANCHOR);
  }
  int32_t zOrder() const {
    return GetField<int32_t>(VT_ZORDER, 0);
  }
  uint8_t opacity() const {
    return GetField<uint8_t>(VT_OPACITY, 0);
  }
  const Vec4f *color() const {
    return GetStruct<const Vec4f *>(VT_COLOR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_CHILDREN);
  }
  NodeType type() const {
    return static_cast<NodeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  Component component_type() const {
    return static_cast<Component>(GetField<uint8_t>(VT_COMPONENT_TYPE, 0));
  }
  const void *component() const {
    return GetPointer<const void *>(VT_COMPONENT);
  }
  template<typename T> const T *component_as() const;
  const Sprite *component_as_Sprite() const {
    return component_type() == Component_Sprite ? static_cast<const Sprite *>(component()) : nullptr;
  }
  const Label *component_as_Label() const {
    return component_type() == Component_Label ? static_cast<const Label *>(component()) : nullptr;
  }
  const Button *component_as_Button() const {
    return component_type() == Component_Button ? static_cast<const Button *>(component()) : nullptr;
  }
  bool enablePhysics() const {
    return GetField<uint8_t>(VT_ENABLEPHYSICS, 0) != 0;
  }
  const Body *physics() const {
    return GetPointer<const Body *>(VT_PHYSICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<Vec2f>(verifier, VT_POSITION) &&
           VerifyField<Vec2f>(verifier, VT_SCALE) &&
           VerifyField<Sizef>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_ROTATION) &&
           VerifyField<Vec2f>(verifier, VT_ANCHOR) &&
           VerifyField<int32_t>(verifier, VT_ZORDER) &&
           VerifyField<uint8_t>(verifier, VT_OPACITY) &&
           VerifyField<Vec4f>(verifier, VT_COLOR) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_COMPONENT_TYPE) &&
           VerifyOffset(verifier, VT_COMPONENT) &&
           VerifyComponent(verifier, component(), component_type()) &&
           VerifyField<uint8_t>(verifier, VT_ENABLEPHYSICS) &&
           VerifyOffset(verifier, VT_PHYSICS) &&
           verifier.VerifyTable(physics()) &&
           verifier.EndTable();
  }
  NodeTreeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NodeTreeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NodeTree> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NodeTreeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Sprite *NodeTree::component_as<Sprite>() const {
  return component_as_Sprite();
}

template<> inline const Label *NodeTree::component_as<Label>() const {
  return component_as_Label();
}

template<> inline const Button *NodeTree::component_as<Button>() const {
  return component_as_Button();
}

struct NodeTreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NodeTree::VT_NAME, name);
  }
  void add_position(const Vec2f *position) {
    fbb_.AddStruct(NodeTree::VT_POSITION, position);
  }
  void add_scale(const Vec2f *scale) {
    fbb_.AddStruct(NodeTree::VT_SCALE, scale);
  }
  void add_size(const Sizef *size) {
    fbb_.AddStruct(NodeTree::VT_SIZE, size);
  }
  void add_rotation(int32_t rotation) {
    fbb_.AddElement<int32_t>(NodeTree::VT_ROTATION, rotation, 0);
  }
  void add_anchor(const Vec2f *anchor) {
    fbb_.AddStruct(NodeTree::VT_ANCHOR, anchor);
  }
  void add_zOrder(int32_t zOrder) {
    fbb_.AddElement<int32_t>(NodeTree::VT_ZORDER, zOrder, 0);
  }
  void add_opacity(uint8_t opacity) {
    fbb_.AddElement<uint8_t>(NodeTree::VT_OPACITY, opacity, 0);
  }
  void add_color(const Vec4f *color) {
    fbb_.AddStruct(NodeTree::VT_COLOR, color);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children) {
    fbb_.AddOffset(NodeTree::VT_CHILDREN, children);
  }
  void add_type(NodeType type) {
    fbb_.AddElement<int8_t>(NodeTree::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_component_type(Component component_type) {
    fbb_.AddElement<uint8_t>(NodeTree::VT_COMPONENT_TYPE, static_cast<uint8_t>(component_type), 0);
  }
  void add_component(flatbuffers::Offset<void> component) {
    fbb_.AddOffset(NodeTree::VT_COMPONENT, component);
  }
  void add_enablePhysics(bool enablePhysics) {
    fbb_.AddElement<uint8_t>(NodeTree::VT_ENABLEPHYSICS, static_cast<uint8_t>(enablePhysics), 0);
  }
  void add_physics(flatbuffers::Offset<Body> physics) {
    fbb_.AddOffset(NodeTree::VT_PHYSICS, physics);
  }
  explicit NodeTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeTreeBuilder &operator=(const NodeTreeBuilder &);
  flatbuffers::Offset<NodeTree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeTree>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeTree> CreateNodeTree(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const Vec2f *position = 0,
    const Vec2f *scale = 0,
    const Sizef *size = 0,
    int32_t rotation = 0,
    const Vec2f *anchor = 0,
    int32_t zOrder = 0,
    uint8_t opacity = 0,
    const Vec4f *color = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children = 0,
    NodeType type = NodeType_BUTTON,
    Component component_type = Component_NONE,
    flatbuffers::Offset<void> component = 0,
    bool enablePhysics = false,
    flatbuffers::Offset<Body> physics = 0) {
  NodeTreeBuilder builder_(_fbb);
  builder_.add_physics(physics);
  builder_.add_component(component);
  builder_.add_children(children);
  builder_.add_color(color);
  builder_.add_zOrder(zOrder);
  builder_.add_anchor(anchor);
  builder_.add_rotation(rotation);
  builder_.add_size(size);
  builder_.add_scale(scale);
  builder_.add_position(position);
  builder_.add_name(name);
  builder_.add_enablePhysics(enablePhysics);
  builder_.add_component_type(component_type);
  builder_.add_type(type);
  builder_.add_opacity(opacity);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const Vec2f *position = 0,
    const Vec2f *scale = 0,
    const Sizef *size = 0,
    int32_t rotation = 0,
    const Vec2f *anchor = 0,
    int32_t zOrder = 0,
    uint8_t opacity = 0,
    const Vec4f *color = 0,
    const std::vector<flatbuffers::Offset<NodeTree>> *children = nullptr,
    NodeType type = NodeType_BUTTON,
    Component component_type = Component_NONE,
    flatbuffers::Offset<void> component = 0,
    bool enablePhysics = false,
    flatbuffers::Offset<Body> physics = 0) {
  return Editor::CreateNodeTree(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      position,
      scale,
      size,
      rotation,
      anchor,
      zOrder,
      opacity,
      color,
      children ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*children) : 0,
      type,
      component_type,
      component,
      enablePhysics,
      physics);
}

flatbuffers::Offset<NodeTree> CreateNodeTree(flatbuffers::FlatBufferBuilder &_fbb, const NodeTreeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpriteT : public flatbuffers::NativeTable {
  typedef Sprite TableType;
  std::string frameName;
  SpriteT() {
  }
};

struct Sprite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpriteT NativeTableType;
  enum {
    VT_FRAMENAME = 4
  };
  const flatbuffers::String *frameName() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAMENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FRAMENAME) &&
           verifier.Verify(frameName()) &&
           verifier.EndTable();
  }
  SpriteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpriteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sprite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpriteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpriteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frameName(flatbuffers::Offset<flatbuffers::String> frameName) {
    fbb_.AddOffset(Sprite::VT_FRAMENAME, frameName);
  }
  explicit SpriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpriteBuilder &operator=(const SpriteBuilder &);
  flatbuffers::Offset<Sprite> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sprite>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sprite> CreateSprite(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> frameName = 0) {
  SpriteBuilder builder_(_fbb);
  builder_.add_frameName(frameName);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sprite> CreateSpriteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *frameName = nullptr) {
  return Editor::CreateSprite(
      _fbb,
      frameName ? _fbb.CreateString(frameName) : 0);
}

flatbuffers::Offset<Sprite> CreateSprite(flatbuffers::FlatBufferBuilder &_fbb, const SpriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LabelT : public flatbuffers::NativeTable {
  typedef Label TableType;
  std::string font;
  std::string text;
  LabelT() {
  }
};

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LabelT NativeTableType;
  enum {
    VT_FONT = 4,
    VT_TEXT = 6
  };
  const flatbuffers::String *font() const {
    return GetPointer<const flatbuffers::String *>(VT_FONT);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FONT) &&
           verifier.Verify(font()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           verifier.EndTable();
  }
  LabelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LabelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Label> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LabelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_font(flatbuffers::Offset<flatbuffers::String> font) {
    fbb_.AddOffset(Label::VT_FONT, font);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Label::VT_TEXT, text);
  }
  explicit LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LabelBuilder &operator=(const LabelBuilder &);
  flatbuffers::Offset<Label> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Label>(end);
    return o;
  }
};

inline flatbuffers::Offset<Label> CreateLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> font = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  LabelBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_font(font);
  return builder_.Finish();
}

inline flatbuffers::Offset<Label> CreateLabelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *font = nullptr,
    const char *text = nullptr) {
  return Editor::CreateLabel(
      _fbb,
      font ? _fbb.CreateString(font) : 0,
      text ? _fbb.CreateString(text) : 0);
}

flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb, const LabelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ButtonT : public flatbuffers::NativeTable {
  typedef Button TableType;
  std::string text;
  std::string textureNormal;
  std::string textureSelected;
  std::string textureDisabled;
  ButtonT() {
  }
};

struct Button FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ButtonT NativeTableType;
  enum {
    VT_TEXT = 4,
    VT_TEXTURENORMAL = 6,
    VT_TEXTURESELECTED = 8,
    VT_TEXTUREDISABLED = 10
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *textureNormal() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTURENORMAL);
  }
  const flatbuffers::String *textureSelected() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTURESELECTED);
  }
  const flatbuffers::String *textureDisabled() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTUREDISABLED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyOffset(verifier, VT_TEXTURENORMAL) &&
           verifier.Verify(textureNormal()) &&
           VerifyOffset(verifier, VT_TEXTURESELECTED) &&
           verifier.Verify(textureSelected()) &&
           VerifyOffset(verifier, VT_TEXTUREDISABLED) &&
           verifier.Verify(textureDisabled()) &&
           verifier.EndTable();
  }
  ButtonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ButtonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Button> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ButtonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ButtonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Button::VT_TEXT, text);
  }
  void add_textureNormal(flatbuffers::Offset<flatbuffers::String> textureNormal) {
    fbb_.AddOffset(Button::VT_TEXTURENORMAL, textureNormal);
  }
  void add_textureSelected(flatbuffers::Offset<flatbuffers::String> textureSelected) {
    fbb_.AddOffset(Button::VT_TEXTURESELECTED, textureSelected);
  }
  void add_textureDisabled(flatbuffers::Offset<flatbuffers::String> textureDisabled) {
    fbb_.AddOffset(Button::VT_TEXTUREDISABLED, textureDisabled);
  }
  explicit ButtonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ButtonBuilder &operator=(const ButtonBuilder &);
  flatbuffers::Offset<Button> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Button>(end);
    return o;
  }
};

inline flatbuffers::Offset<Button> CreateButton(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> textureNormal = 0,
    flatbuffers::Offset<flatbuffers::String> textureSelected = 0,
    flatbuffers::Offset<flatbuffers::String> textureDisabled = 0) {
  ButtonBuilder builder_(_fbb);
  builder_.add_textureDisabled(textureDisabled);
  builder_.add_textureSelected(textureSelected);
  builder_.add_textureNormal(textureNormal);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<Button> CreateButtonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const char *textureNormal = nullptr,
    const char *textureSelected = nullptr,
    const char *textureDisabled = nullptr) {
  return Editor::CreateButton(
      _fbb,
      text ? _fbb.CreateString(text) : 0,
      textureNormal ? _fbb.CreateString(textureNormal) : 0,
      textureSelected ? _fbb.CreateString(textureSelected) : 0,
      textureDisabled ? _fbb.CreateString(textureDisabled) : 0);
}

flatbuffers::Offset<Button> CreateButton(flatbuffers::FlatBufferBuilder &_fbb, const ButtonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BodyT : public flatbuffers::NativeTable {
  typedef Body TableType;
  int32_t id;
  std::unique_ptr<Vec2f> pos;
  BodyType type;
  std::vector<std::unique_ptr<FixtureT>> fixtures;
  BodyT()
      : id(0),
        type(BodyType_STATIC) {
  }
};

struct Body FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BodyT NativeTableType;
  enum {
    VT_ID = 4,
    VT_POS = 6,
    VT_TYPE = 8,
    VT_FIXTURES = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const Vec2f *pos() const {
    return GetStruct<const Vec2f *>(VT_POS);
  }
  BodyType type() const {
    return static_cast<BodyType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fixture>> *fixtures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fixture>> *>(VT_FIXTURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<Vec2f>(verifier, VT_POS) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FIXTURES) &&
           verifier.Verify(fixtures()) &&
           verifier.VerifyVectorOfTables(fixtures()) &&
           verifier.EndTable();
  }
  BodyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BodyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Body> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BodyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Body::VT_ID, id, 0);
  }
  void add_pos(const Vec2f *pos) {
    fbb_.AddStruct(Body::VT_POS, pos);
  }
  void add_type(BodyType type) {
    fbb_.AddElement<int8_t>(Body::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_fixtures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fixture>>> fixtures) {
    fbb_.AddOffset(Body::VT_FIXTURES, fixtures);
  }
  explicit BodyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BodyBuilder &operator=(const BodyBuilder &);
  flatbuffers::Offset<Body> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Body>(end);
    return o;
  }
};

inline flatbuffers::Offset<Body> CreateBody(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const Vec2f *pos = 0,
    BodyType type = BodyType_STATIC,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fixture>>> fixtures = 0) {
  BodyBuilder builder_(_fbb);
  builder_.add_fixtures(fixtures);
  builder_.add_pos(pos);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Body> CreateBodyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const Vec2f *pos = 0,
    BodyType type = BodyType_STATIC,
    const std::vector<flatbuffers::Offset<Fixture>> *fixtures = nullptr) {
  return Editor::CreateBody(
      _fbb,
      id,
      pos,
      type,
      fixtures ? _fbb.CreateVector<flatbuffers::Offset<Fixture>>(*fixtures) : 0);
}

flatbuffers::Offset<Body> CreateBody(flatbuffers::FlatBufferBuilder &_fbb, const BodyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FixtureT : public flatbuffers::NativeTable {
  typedef Fixture TableType;
  std::string name;
  FixtureType type;
  float density;
  float friction;
  float restitution;
  std::vector<Vec2f> points;
  FixtureT()
      : type(FixtureType_POLYGON),
        density(0.0f),
        friction(0.0f),
        restitution(0.0f) {
  }
};

struct Fixture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FixtureT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DENSITY = 8,
    VT_FRICTION = 10,
    VT_RESTITUTION = 12,
    VT_POINTS = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  FixtureType type() const {
    return static_cast<FixtureType>(GetField<int8_t>(VT_TYPE, 0));
  }
  float density() const {
    return GetField<float>(VT_DENSITY, 0.0f);
  }
  float friction() const {
    return GetField<float>(VT_FRICTION, 0.0f);
  }
  float restitution() const {
    return GetField<float>(VT_RESTITUTION, 0.0f);
  }
  const flatbuffers::Vector<const Vec2f *> *points() const {
    return GetPointer<const flatbuffers::Vector<const Vec2f *> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<float>(verifier, VT_DENSITY) &&
           VerifyField<float>(verifier, VT_FRICTION) &&
           VerifyField<float>(verifier, VT_RESTITUTION) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.Verify(points()) &&
           verifier.EndTable();
  }
  FixtureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FixtureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Fixture> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixtureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FixtureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Fixture::VT_NAME, name);
  }
  void add_type(FixtureType type) {
    fbb_.AddElement<int8_t>(Fixture::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_density(float density) {
    fbb_.AddElement<float>(Fixture::VT_DENSITY, density, 0.0f);
  }
  void add_friction(float friction) {
    fbb_.AddElement<float>(Fixture::VT_FRICTION, friction, 0.0f);
  }
  void add_restitution(float restitution) {
    fbb_.AddElement<float>(Fixture::VT_RESTITUTION, restitution, 0.0f);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const Vec2f *>> points) {
    fbb_.AddOffset(Fixture::VT_POINTS, points);
  }
  explicit FixtureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FixtureBuilder &operator=(const FixtureBuilder &);
  flatbuffers::Offset<Fixture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fixture>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fixture> CreateFixture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    FixtureType type = FixtureType_POLYGON,
    float density = 0.0f,
    float friction = 0.0f,
    float restitution = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2f *>> points = 0) {
  FixtureBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_restitution(restitution);
  builder_.add_friction(friction);
  builder_.add_density(density);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fixture> CreateFixtureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    FixtureType type = FixtureType_POLYGON,
    float density = 0.0f,
    float friction = 0.0f,
    float restitution = 0.0f,
    const std::vector<const Vec2f *> *points = nullptr) {
  return Editor::CreateFixture(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      type,
      density,
      friction,
      restitution,
      points ? _fbb.CreateVector<const Vec2f *>(*points) : 0);
}

flatbuffers::Offset<Fixture> CreateFixture(flatbuffers::FlatBufferBuilder &_fbb, const FixtureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JointT : public flatbuffers::NativeTable {
  typedef Joint TableType;
  int32_t bodyA;
  int32_t bodyB;
  std::unique_ptr<Vec2f> posA;
  std::unique_ptr<Vec2f> posB;
  JointType type;
  JointT()
      : bodyA(0),
        bodyB(0),
        type(JointType_REVOLUTE) {
  }
};

struct Joint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JointT NativeTableType;
  enum {
    VT_BODYA = 4,
    VT_BODYB = 6,
    VT_POSA = 8,
    VT_POSB = 10,
    VT_TYPE = 12
  };
  int32_t bodyA() const {
    return GetField<int32_t>(VT_BODYA, 0);
  }
  int32_t bodyB() const {
    return GetField<int32_t>(VT_BODYB, 0);
  }
  const Vec2f *posA() const {
    return GetStruct<const Vec2f *>(VT_POSA);
  }
  const Vec2f *posB() const {
    return GetStruct<const Vec2f *>(VT_POSB);
  }
  JointType type() const {
    return static_cast<JointType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BODYA) &&
           VerifyField<int32_t>(verifier, VT_BODYB) &&
           VerifyField<Vec2f>(verifier, VT_POSA) &&
           VerifyField<Vec2f>(verifier, VT_POSB) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  JointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Joint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bodyA(int32_t bodyA) {
    fbb_.AddElement<int32_t>(Joint::VT_BODYA, bodyA, 0);
  }
  void add_bodyB(int32_t bodyB) {
    fbb_.AddElement<int32_t>(Joint::VT_BODYB, bodyB, 0);
  }
  void add_posA(const Vec2f *posA) {
    fbb_.AddStruct(Joint::VT_POSA, posA);
  }
  void add_posB(const Vec2f *posB) {
    fbb_.AddStruct(Joint::VT_POSB, posB);
  }
  void add_type(JointType type) {
    fbb_.AddElement<int8_t>(Joint::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit JointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JointBuilder &operator=(const JointBuilder &);
  flatbuffers::Offset<Joint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Joint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Joint> CreateJoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bodyA = 0,
    int32_t bodyB = 0,
    const Vec2f *posA = 0,
    const Vec2f *posB = 0,
    JointType type = JointType_REVOLUTE) {
  JointBuilder builder_(_fbb);
  builder_.add_posB(posB);
  builder_.add_posA(posA);
  builder_.add_bodyB(bodyB);
  builder_.add_bodyA(bodyA);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Joint> CreateJoint(flatbuffers::FlatBufferBuilder &_fbb, const JointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EditorRootT *EditorRoot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EditorRootT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EditorRoot::UnPackTo(EditorRootT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = textures(); if (_e) { _o->textures.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textures[_i] = _e->Get(_i)->str(); } } };
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<NodeTreeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<EditorRoot> EditorRoot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EditorRootT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEditorRoot(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EditorRoot> CreateEditorRoot(flatbuffers::FlatBufferBuilder &_fbb, const EditorRootT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EditorRootT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _textures = _o->textures.size() ? _fbb.CreateVectorOfStrings(_o->textures) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateNodeTree(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Editor::CreateEditorRoot(
      _fbb,
      _textures,
      _nodes);
}

inline NodeTreeT *NodeTree::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NodeTreeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NodeTree::UnPackTo(NodeTreeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
  { auto _e = size(); if (_e) _o->size = std::unique_ptr<Sizef>(new Sizef(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
  { auto _e = anchor(); if (_e) _o->anchor = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
  { auto _e = zOrder(); _o->zOrder = _e; };
  { auto _e = opacity(); _o->opacity = _e; };
  { auto _e = color(); if (_e) _o->color = std::unique_ptr<Vec4f>(new Vec4f(*_e)); };
  { auto _e = children(); if (_e) { _o->children.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->children[_i] = std::unique_ptr<NodeTreeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = component_type(); _o->component.type = _e; };
  { auto _e = component(); if (_e) _o->component.value = ComponentUnion::UnPack(_e, component_type(), _resolver); };
  { auto _e = enablePhysics(); _o->enablePhysics = _e; };
  { auto _e = physics(); if (_e) _o->physics = std::unique_ptr<BodyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<NodeTree> NodeTree::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NodeTreeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNodeTree(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NodeTree> CreateNodeTree(flatbuffers::FlatBufferBuilder &_fbb, const NodeTreeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NodeTreeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _position = _o->position ? _o->position.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _size = _o->size ? _o->size.get() : 0;
  auto _rotation = _o->rotation;
  auto _anchor = _o->anchor ? _o->anchor.get() : 0;
  auto _zOrder = _o->zOrder;
  auto _opacity = _o->opacity;
  auto _color = _o->color ? _o->color.get() : 0;
  auto _children = _o->children.size() ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>> (_o->children.size(), [](size_t i, _VectorArgs *__va) { return CreateNodeTree(*__va->__fbb, __va->__o->children[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _type = _o->type;
  auto _component_type = _o->component.type;
  auto _component = _o->component.Pack(_fbb);
  auto _enablePhysics = _o->enablePhysics;
  auto _physics = _o->physics ? CreateBody(_fbb, _o->physics.get(), _rehasher) : 0;
  return Editor::CreateNodeTree(
      _fbb,
      _name,
      _position,
      _scale,
      _size,
      _rotation,
      _anchor,
      _zOrder,
      _opacity,
      _color,
      _children,
      _type,
      _component_type,
      _component,
      _enablePhysics,
      _physics);
}

inline SpriteT *Sprite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpriteT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Sprite::UnPackTo(SpriteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frameName(); if (_e) _o->frameName = _e->str(); };
}

inline flatbuffers::Offset<Sprite> Sprite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpriteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSprite(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sprite> CreateSprite(flatbuffers::FlatBufferBuilder &_fbb, const SpriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpriteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frameName = _o->frameName.empty() ? 0 : _fbb.CreateString(_o->frameName);
  return Editor::CreateSprite(
      _fbb,
      _frameName);
}

inline LabelT *Label::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LabelT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Label::UnPackTo(LabelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = font(); if (_e) _o->font = _e->str(); };
  { auto _e = text(); if (_e) _o->text = _e->str(); };
}

inline flatbuffers::Offset<Label> Label::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLabel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb, const LabelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LabelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _font = _o->font.empty() ? 0 : _fbb.CreateString(_o->font);
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  return Editor::CreateLabel(
      _fbb,
      _font,
      _text);
}

inline ButtonT *Button::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ButtonT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Button::UnPackTo(ButtonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); };
  { auto _e = textureNormal(); if (_e) _o->textureNormal = _e->str(); };
  { auto _e = textureSelected(); if (_e) _o->textureSelected = _e->str(); };
  { auto _e = textureDisabled(); if (_e) _o->textureDisabled = _e->str(); };
}

inline flatbuffers::Offset<Button> Button::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ButtonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateButton(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Button> CreateButton(flatbuffers::FlatBufferBuilder &_fbb, const ButtonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ButtonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  auto _textureNormal = _o->textureNormal.empty() ? 0 : _fbb.CreateString(_o->textureNormal);
  auto _textureSelected = _o->textureSelected.empty() ? 0 : _fbb.CreateString(_o->textureSelected);
  auto _textureDisabled = _o->textureDisabled.empty() ? 0 : _fbb.CreateString(_o->textureDisabled);
  return Editor::CreateButton(
      _fbb,
      _text,
      _textureNormal,
      _textureSelected,
      _textureDisabled);
}

inline BodyT *Body::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BodyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Body::UnPackTo(BodyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
  { auto _e = type(); _o->type = _e; };
  { auto _e = fixtures(); if (_e) { _o->fixtures.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fixtures[_i] = std::unique_ptr<FixtureT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Body> Body::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBody(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Body> CreateBody(flatbuffers::FlatBufferBuilder &_fbb, const BodyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BodyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _type = _o->type;
  auto _fixtures = _o->fixtures.size() ? _fbb.CreateVector<flatbuffers::Offset<Fixture>> (_o->fixtures.size(), [](size_t i, _VectorArgs *__va) { return CreateFixture(*__va->__fbb, __va->__o->fixtures[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Editor::CreateBody(
      _fbb,
      _id,
      _pos,
      _type,
      _fixtures);
}

inline FixtureT *Fixture::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FixtureT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Fixture::UnPackTo(FixtureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = type(); _o->type = _e; };
  { auto _e = density(); _o->density = _e; };
  { auto _e = friction(); _o->friction = _e; };
  { auto _e = restitution(); _o->restitution = _e; };
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } };
}

inline flatbuffers::Offset<Fixture> Fixture::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixtureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFixture(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Fixture> CreateFixture(flatbuffers::FlatBufferBuilder &_fbb, const FixtureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FixtureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _density = _o->density;
  auto _friction = _o->friction;
  auto _restitution = _o->restitution;
  auto _points = _o->points.size() ? _fbb.CreateVectorOfStructs(_o->points) : 0;
  return Editor::CreateFixture(
      _fbb,
      _name,
      _type,
      _density,
      _friction,
      _restitution,
      _points);
}

inline JointT *Joint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new JointT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Joint::UnPackTo(JointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bodyA(); _o->bodyA = _e; };
  { auto _e = bodyB(); _o->bodyB = _e; };
  { auto _e = posA(); if (_e) _o->posA = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
  { auto _e = posB(); if (_e) _o->posB = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
  { auto _e = type(); _o->type = _e; };
}

inline flatbuffers::Offset<Joint> Joint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Joint> CreateJoint(flatbuffers::FlatBufferBuilder &_fbb, const JointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const JointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bodyA = _o->bodyA;
  auto _bodyB = _o->bodyB;
  auto _posA = _o->posA ? _o->posA.get() : 0;
  auto _posB = _o->posB ? _o->posB.get() : 0;
  auto _type = _o->type;
  return Editor::CreateJoint(
      _fbb,
      _bodyA,
      _bodyB,
      _posA,
      _posB,
      _type);
}

inline bool VerifyComponent(flatbuffers::Verifier &verifier, const void *obj, Component type) {
  switch (type) {
    case Component_NONE: {
      return true;
    }
    case Component_Sprite: {
      auto ptr = reinterpret_cast<const Sprite *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Component_Label: {
      auto ptr = reinterpret_cast<const Label *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Component_Button: {
      auto ptr = reinterpret_cast<const Button *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyComponentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyComponent(
        verifier,  values->Get(i), types->GetEnum<Component>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ComponentUnion::UnPack(const void *obj, Component type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Component_Sprite: {
      auto ptr = reinterpret_cast<const Sprite *>(obj);
      return ptr->UnPack(resolver);
    }
    case Component_Label: {
      auto ptr = reinterpret_cast<const Label *>(obj);
      return ptr->UnPack(resolver);
    }
    case Component_Button: {
      auto ptr = reinterpret_cast<const Button *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ComponentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Component_Sprite: {
      auto ptr = reinterpret_cast<const SpriteT *>(value);
      return CreateSprite(_fbb, ptr, _rehasher).Union();
    }
    case Component_Label: {
      auto ptr = reinterpret_cast<const LabelT *>(value);
      return CreateLabel(_fbb, ptr, _rehasher).Union();
    }
    case Component_Button: {
      auto ptr = reinterpret_cast<const ButtonT *>(value);
      return CreateButton(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ComponentUnion::ComponentUnion(const ComponentUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Component_Sprite: {
      value = new SpriteT(*reinterpret_cast<SpriteT *>(u.value));
      break;
    }
    case Component_Label: {
      value = new LabelT(*reinterpret_cast<LabelT *>(u.value));
      break;
    }
    case Component_Button: {
      value = new ButtonT(*reinterpret_cast<ButtonT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ComponentUnion::Reset() {
  switch (type) {
    case Component_Sprite: {
      auto ptr = reinterpret_cast<SpriteT *>(value);
      delete ptr;
      break;
    }
    case Component_Label: {
      auto ptr = reinterpret_cast<LabelT *>(value);
      delete ptr;
      break;
    }
    case Component_Button: {
      auto ptr = reinterpret_cast<ButtonT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Component_NONE;
}

inline const Editor::EditorRoot *GetEditorRoot(const void *buf) {
  return flatbuffers::GetRoot<Editor::EditorRoot>(buf);
}

inline bool VerifyEditorRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Editor::EditorRoot>(nullptr);
}

inline void FinishEditorRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Editor::EditorRoot> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<EditorRootT> UnPackEditorRoot(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<EditorRootT>(GetEditorRoot(buf)->UnPack(res));
}

}  // namespace Editor

#endif  // FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_
